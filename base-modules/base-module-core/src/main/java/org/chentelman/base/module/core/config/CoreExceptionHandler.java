package org.chentelman.base.module.core.config;

import java.util.stream.Collectors;

import org.chentelman.base.module.core.exception.BaseException;
import org.chentelman.base.module.core.exception.BaseValidationException;
import org.chentelman.base.module.core.exception.BaseValidationFailure;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

/**
 * Implementation of a generic exception handler to handle system exceptions
 *
 * Handled exception
 *  - BaseException
 *    Those are the "business" exceptions indicating an issue completing the requested task
 *
 *  - MethodArgumentNotValidException
 *    This is generated by spring in case any validation checks fail
 *
 *  - MethodArgumentTypeMismatchException
 *    This is generated by spring in case method argument type mismatch is found
 *
 *  - Exception
 *    This is a generic handler for all exceptions not being processed by any of the other handlers
 *    will result in an internal server error being generated
 */
@Order(Ordered.LOWEST_PRECEDENCE)
@RestControllerAdvice
@ConditionalOnMissingBean(CoreExceptionHandler.class)
public class CoreExceptionHandler extends BaseExceptionHandler {

	/**
	 * Those are the "business" exceptions indicating an issue completing the requested task
	 */
	@ExceptionHandler(BaseException.class)
	public final ResponseEntity<BaseException> handleAllApiErrors(final BaseException ex) {
		return generateResponse (ex);
	}

	/**
	 * This is generated by spring in case any validation checks fail
	 */
	@ExceptionHandler(MethodArgumentNotValidException.class)
	public final ResponseEntity<BaseValidationException> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) {
		BaseValidationException ve = new BaseValidationException ();

		// build validation info
		ex.getBindingResult().getFieldErrors().stream()
			.map(err -> new BaseValidationFailure(
				err.getObjectName(),
				err.getField(),
				err.getRejectedValue(),
				err.getDefaultMessage()
			))
			.distinct()
			.collect(Collectors.toCollection(ve::getValidations));

		return generateResponse (ve);
	}

	/**
	 * This is generated by spring in case method argument type mismatch is found
	 */
	@ExceptionHandler(MethodArgumentTypeMismatchException.class)
	public final ResponseEntity<BaseValidationException> handleMethodArgumentTypeMismatchException(MethodArgumentTypeMismatchException ex) {
		BaseValidationException ve = new BaseValidationException ();

		// build validation info
		ve.getValidations().add(
			new BaseValidationFailure(
				ex.getRequiredType(),
				ex.getName(),
				ex.getValue(),
				"Invalid value"
			)
		);

		return generateResponse (ve);
	}

	/**
	 * Handling of unhandled exceptions. exceptions are logged and converted to internal server errors
	 */
	@ExceptionHandler(Exception.class)
	public final ResponseEntity<BaseException> handleInternalServerException (final Exception ex) {
		logger.error("got exception : {}", ex.getClass().getCanonicalName());
		for (var trace : ex.getStackTrace())
			logger.error("{}", trace);

		return generateResponse (
			new BaseException(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage())
		);
	}
}




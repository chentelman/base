package org.chentelman.base.module.http.config;

import javax.naming.AuthenticationException;

import org.chentelman.base.module.core.config.BaseExceptionHandler;
import org.chentelman.base.module.http.exception.BadRequestException;
import org.chentelman.base.module.http.exception.UnauthorizedException;
import org.springframework.beans.TypeMismatchException;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConversionException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * Implementation of a generic exception handler to handle system exceptions
 *
 * Handled exception
 *  - HttpMessageConversionException
 *    This is the error raised by spring in case the request body is not able to be converted to the specified class
 *
 *  - TypeMismatchException
 *    This is generated by spring in case any provided type is able to be converted
 *
 *  - AuthenticationException
 *    This is generated in case the user is not able to be authenticated
 */
@Order(Ordered.LOWEST_PRECEDENCE)
@RestControllerAdvice
@ConditionalOnMissingBean(HttpExceptionHandler.class)
public class HttpExceptionHandler extends BaseExceptionHandler {

	/**
	 * This is the error raised by spring in case the request body is not able to be converted to the specified class
	 */
	@ExceptionHandler(HttpMessageConversionException.class)
	public final ResponseEntity<BadRequestException> handleHttpMessageConversionException(HttpMessageConversionException ex) {
		logger.warn(ex.getMessage());

		return generateResponse (
			new BadRequestException ("Invalid Json")
		);
	}

	/**
	 * This is generated by spring in case any provided type is able to be converted
	 */
	@ExceptionHandler(TypeMismatchException.class)
	public final ResponseEntity<BadRequestException> handleTypeMismatchException(TypeMismatchException ex) {
		logger.warn(ex.getMessage());

		return generateResponse (
			new BadRequestException ("Invalid parameter type")
		);
	}

	/**
	 * This is generated in case the user is not able to be authenticated
	 */
	@ExceptionHandler(AuthenticationException.class)
	public final ResponseEntity<UnauthorizedException> handleAuthenticationException(AuthenticationException ex) {
		UnauthorizedException bre = new UnauthorizedException (ex.getMessage());
		logger.warn(ex.getMessage());

		return generateResponse (bre);
	}
}



